<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">	
		
		<title>genn.ai</title><head>
			    <body>
				        
<h2 id="languagemanual_dml">LanguageManual DML</h2>

<h3 id="from_★">FROM ★</h3>

<pre><code>FROM は、Tupleを入力先から読み込みます。</code></pre>

<h4 id="入力先が外部の場合">入力先が外部の場合</h4>

<pre><code>FROM schema_name AS schema_alias, ... USING spout_processor</code></pre>

<ul>
<li>schema_name には、Tuple名もしくはView名を指定します。</li>

<li>schema_alias には、クエリ内で使用するTupleもしくはViewの別名を指定します。</li>

<li>spout_processor には、読み込みに使用するプロセッサを指定します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>FROM userAction1 AS ua1, userAction2 AS ua2, view1 AS v1 USING kafka_spout()</code></pre>

<p>外部入力は、一つのTopologyに対して一つしか定義できません。</p>

<h4 id="spout_processor">Spout Processor</h4>

<p>kafka_spout</p>

<blockquote>
<p>TupleをKafkaから読み込みます。システムのデフォルトとして動作します。</p>
</blockquote>

<pre><code>kafka_spout()</code></pre>

<h4 id="入力先が内部（ストリーム）の場合">入力先が内部（ストリーム）の場合</h4>

<pre><code>FROM stream_name[(schema_alias, ...)], ...</code></pre>

<ul>
<li>stream_name には、入力先のストリーム名を指定します。</li>
</ul>

<p>ストリームからすべてのTupleを読み込む場合</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>FROM s1, s2</code></pre>

<p>ストリームから特定のTupleのみを読み込む場合</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>FROM s1(ua1, ua2), s2(v1)</code></pre>
<hr />
<h3 id="into_★">INTO ★</h3>

<p>INTO は、ストリームを分岐・合流させます。</p>

<pre><code>INTO stream_name</code></pre>

<ul>
<li>stream_name には、出力するストリーム名を指定します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>FROM userAction1 AS ua1, userAction2 AS ua2, view1 AS v1 USING kafka_spout() INTO s1</code></pre>

<p>INTO を使って出力したストリームは、FROM で読み込みます。</p>

<blockquote>
<p>分岐</p>
</blockquote>

<pre><code> FROM userAction1 AS ua1, userAction2 AS ua2, view1 AS v1 USING kafka_spout() INTO s1;
FROM s1(ua1) ...
FROM s1(ua2) ...
FROM s1(v1) ...</code></pre>

<blockquote>
<p>合流</p>
</blockquote>

<pre><code> FROM s1(ua1) ... INTO s2;
FROM s1(ua2) ... INTO s3;
FROM s1(v1) ... INTO s4;
FROM s2, s3, s4 ...</code></pre>
<hr />
<h3 id="join_★">JOIN ★</h3>

<p>JOINは、外部データをフィールドとしてTupleに結合します。</p>

<pre><code>JOIN join_name ON join_condition TO join_fields USING fetch_processor

join_condition:
join_name.key_field = field [AND join_name.key_field = field AND join_name.key_field &lt;&gt; 0]

join_fields:
join_name.join_field AS field_alias, ...</code></pre>

<ul>
<li>join_name には、結合する名称を指定します。join_condition や join_fields で、外部データのフィールドを識別する為に使用します。</li>

<li>join_condition には、結合条件を指定します。 結合データのキーフィールド = Tupleのフィールド を、結合データが一意になるように指定してください。 複合条件の場合は、AND で指定します。結合データのキーフィールドに対して、定数で条件を指定することもできます。</li>

<li>join_fields には、結合するフィールドを指定します。 結合データのフィールド名 AS Tupleに結合する際のフィールド名 を指定します。フィールドはTupleに追加されます。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>JOIN j1 ON j1.code1 = field1 AND j1.code2 = field2 AND j1.del = 0
  TO j1.name AS field10, j1.type AS field11
  USING mongo_fetch('db1', 'col1')</code></pre>
<hr />
<h3 id="filter">FILTER</h3>

<p>FILTER は、単一のTupleに対してTupleの通過を判定します。</p>

<pre><code>FILTER condition</code></pre>

<ul>
<li>condition には、フィルタの条件を指定します。</li>
</ul>

<blockquote>
<p>condition の符号には、以下のものを指定します。</p>

<ul>
<li>= もしくは ==</li>

<li>&lt;&gt; もしくは !=</li>

<li>
<blockquote></blockquote>
</li>

<li>
<blockquote>
<p>=</p>
</blockquote>
</li>

<li>&lt;</li>

<li>&lt;=</li>

<li>LIKE</li>

<li>REGEXP</li>

<li>IN</li>

<li>ALL</li>

<li>BETWEEN</li>

<li>AND</li>

<li>OR</li>

<li>NOT</li>
</ul>
</blockquote>

<h4 id="_______">=, ==, &lt;&gt;, !=, &gt;, &gt;=, &lt;, &lt;=</h4>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field1 &gt;= 10</code></pre>

<h4 id="like">LIKE</h4>

<p>LIKEで使用できるワイルドカードは、”%”（複数文字）と”_”（一文字）です。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field2 LIKE 't%'</code></pre>

<h4 id="regexp">REGEXP</h4>

<p>REGEXPで使用できる正規表現は、java/util/regex/Patternと同じ書式を採用しています。 http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field3 REGEXP '^[A-Z]{2}-[0-9]{4}$'</code></pre>

<h4 id="in_all">IN, ALL</h4>

<p>INは、LISTフィールドに対して値が一つでも含まれているかを調べます。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field4 IN ('tokyo', 'kyoto', 'osaka')</code></pre>

<p>ALLは、LISTフィールドに対して値がすべて含まれているかを調べます。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field4 ALL ('tokyo', 'kyoto', 'osaka')</code></pre>

<h4 id="between">BETWEEN</h4>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field1 10 AND 100</code></pre>

<h4 id="and_or_not">AND, OR, NOT</h4>

<p>AND, OR, NOT は入れ子にすることが可能です。優先順位はNOT, AND, ORの順に処理されます。 優先順位は、()を使用して変更できます。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field1 &lt;= 30 AND (field5 BETWEEN 10 AND 100 OR field2 LIKE 'A%')</code></pre>

<h4 id="struct型フィールドの比較">STRUCT型フィールドの比較</h4>

<p>TupleのフィールドがSTRUCT型の場合は、フィールド値を以下のように比較します。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field6.member3 = 100</code></pre>

<h4 id="list型フィールドの比較">LIST型フィールドの比較</h4>

<p>TupleのフィールドがLIST型の場合は、フィールド値を以下のように比較します。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field4[0] = 'tokyo'</code></pre>

<h4 id="map型フィールドの比較">MAP型フィールドの比較</h4>

<p>TupleのフィールドがMAP型の場合は、フィールドの値を以下のように比較します。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>field7['visa'] = true</code></pre>

<h4 id="定数_★">定数 ★</h4>

<p>条件に指定できる定数は、以下になります。</p>

<ul>
<li>
<p>文字列 シングルクォートまたはダブルクォートでくくった文字列</p>
</li>

<li>
<p>INT値 number only</p>
</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>2147483647</code></pre>

<ul>
<li>DOUBLE値 number.number</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>12.5</code></pre>

<ul>
<li>BIGINT値 numberL</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>9223372036854775807L</code></pre>

<ul>
<li>SMALLINT値 numberS</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>32767S</code></pre>

<ul>
<li>TINYINT値 numberY</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>255Y</code></pre>

<ul>
<li>FLOAT値 number.numberF</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>12.5F</code></pre>

<ul>
<li>BOOLEAN値 true|false</li>
</ul>
<hr />
<h3 id="filter_group">FILTER GROUP</h3>

<p>FILTER GROUP は、複数のTupleに対してTupleの通過を判定します。</p>

<pre><code>FILTER GROUP EXPIRE period [STATE TO state_field]
  condition, ...</code></pre>

<ul>
<li>period には、フィルタの状態を保持する期間を指定します。</li>

<li>state_field には、フィルタの状態を出力するフィールド名を指定します。フィルタを通過すると、指定したフィールド名で Tupleに状態フィールドを追加します。STATE TO clause を省略した場合は、状態フィールドは追加しません。 ★</li>

<li>condition には、フィルタ条件を指定します。カンマ区切りで、複数のTupleに対する条件を指定します。 カンマ区切りで指定した条件をすべて満たせば、Tupleはフィルタを通過します。 すべての条件を満たした場合、最後に到着したTupleがフィルタを通過し、フィルタの状態は初期化されます。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>FILTER GROUP EXPIRE 7DAYS STATE TO fg_state
  ua1.field1 &gt;= 10 AND ua1.field8 = true,
  (ua2.field1 &lt;= 30 AND ua2.field2.member2 BETWEEN 2 AND 7) OR ua3.field5 LIKE 'A%'</code></pre>

<blockquote>
<p>ua1, ua2, ua3の３つのTupleに対してフィルタを実行します。条件１と条件２（※）の両方を満たせば、Tupleはフィルタを通過します。 （※）条件１はua1に対するフィルタで、条件２はua2とua3に対するフィルタです。</p>

<p>条件２は、ua2とua3の条件を”OR”で指定しているので、ua1かつua2の条件を満たすか、ua1かつua3の条件を満たすことで すべての条件は満たされます。</p>

<p>条件１もしくは条件２のいずれかを満たした状態を７日間保持します。 例えば、条件１を最後に満たした状態で、条件２の条件を満たすまでの期間が７日以内であれば、条件１と条件２は満たされますが、 ８日以上の日数が経過していた場合、条件１の状態は初期化されてしまう為、条件２のみ満たしている状態になります。</p>

<p>state_fieldに”fg_state”を指定しているので、フィルタの状態を”fg_state”フィールドとしてTupleに追加します。 fg_stateは、条件１と条件２のそれぞれを満たした日時が格納されます。条件の数と等しいTIMESTAMPのLISTになります。</p>
</blockquote>

<h4 id="period">period</h4>

<ul>
<li>秒で指定 number(SECONDS|SEC)</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>    30SECONDS</code></pre>

<ul>
<li>分で指定 number(MINUTES|MIN)</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>55MIN</code></pre>

<ul>
<li>時間で指定 number(HOURS|H)</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>55HOURS</code></pre>

<ul>
<li>日で指定 number(DAYS|D)</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>    15DAYS</code></pre>
<hr />
<h3 id="each">EACH</h3>

<p>EACH は、Tupleの集計や編集を実行します。</p>

<p>EACH expr, </p>

<ul>
<li>exprには、集計関数もしくは編集関数、フィールドのアクセサを指定します。</li>
</ul>

<h4 id="集計関数">集計関数</h4>

<ul>
<li>Tupleの到着数をカウントします。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH count() AS cnt1</code></pre>

<ul>
<li>到着したフィールドの値を合計します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH sum(field1) AS sum1</code></pre>

<ul>
<li>到着したフィールドの値の平均を計算します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH avg(field1) AS avg1</code></pre>

<h4 id="編集関数">編集関数</h4>

<ul>
<li>フィールドの値がNULLであれば、代替えの値で置き換えます。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH ifnull(field1, 0) AS field1</code></pre>

<ul>
<li>STRING型のフィールドの値を連結したフィールドを作成します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH concat(field1, '-', field2) AS new_field</code></pre>

<h4 id="関数の引数_★">関数の引数 ★</h4>

<p>定数に関しては、関数の種類が増えてきてから改めて記述する。</p>

<h4 id="フィールドのアクセサ">フィールドのアクセサ</h4>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH field1, field6.member1 AS field10, field7['visa'] AS visa</code></pre>

<blockquote>
<p>field1はそのまま、field6.member1をfield10フィールドへ、field7[visa]をvisaフィールドへ抽出します。</p>
</blockquote>
<hr />
<h3 id="group">GROUP</h3>

<p>BEGIN GROUP … END GROUP で囲まれたクエリを、グループで実行します。</p>

<pre><code>BEGIN GROUP BY field, ...
  [END GROUP &amp;#124; TO STREAM]</code></pre>

<ul>
<li>field には、グループ化するフィールドの名前を指定します。</li>
</ul>

<h4 id="each_をグループで実行する">EACH をグループで実行する</h4>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>BEGIN GROUP BY user_name
EACH user_name, count() AS gc1
EMIT * USING mongo_persist('db1', 'col2', 'user_name');
END GROUP</code></pre>

<blockquote>
<p>user_name ごとに（ユーザごとに）Tupleがカウントされます。</p>
</blockquote>

<h4 id="filter_group_をグループで実行する">FILTER GROUP をグループで実行する</h4>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>BEGIN GROUP BY user_name
FILTER GROUP EXPIRE 1DAYS
  ua1.field1 &gt;= 10 AND ua1.field8 = true,
  (ua2.field1 &lt;= 30 AND ua2.field2.member3 BETWEEN 2 AND 7) OR ua3.field5 LIKE 'A%'
EMIT * USING mongo_persist('db1', 'col3')
END GROUP</code></pre>

<blockquote>
<p>user_nameごとに（ユーザごとに）フィルタが判定されます。 特定のユーザが条件１と条件２を満たしているかを判定し、FILTER GROUP の状態はユーザごとに保持されます。</p>
</blockquote>

<h4 id="group_のネスト">GROUP のネスト</h4>

<p>GROUPはネストできます。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH ...  &lt;- グループ化せずに実行
BEGIN GROUP BY date
  EACH ...  &lt;- date ごとに実行される
  BEGIN GROUP BY area
    EACH ...  &lt;- date + area ごとに実行される
  END GROUP 
END GROUP
EACH ...  &lt;- グループ化せずに実行</code></pre>

<p>TO STREAM で、すべてのグループを解除します。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EACH ...  &lt;- グループ化せずに実行
BEGIN GROUP BY date
  EACH ...  &lt;- date ごとに実行される
  BEGIN GROUP BY area
    EACH ...  &lt;- date + area ごとに実行される
TO STREAM
EACH ...  &lt;- グループ化せずに実行</code></pre>

<p>END GROUP と TO STREAM は、グループ化を解除する必要がなければ省略可能です。 ★</p>
<hr />
<h3 id="emit_★">EMIT ★</h3>

<p>EMITは、Tupleを外部へ出力します。</p>

<p>EMIT output_field, … USING emit_processor</p>

<ul>
<li>output_field には、出力するフィールド名を指定します。ワイルドカード（*）を指定できます。</li>

<li>emit_processor には、出力に使用するプロセッサを指定します。</li>
</ul>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>EMIT field1, field2, field3 USING mongo_persist('db1', 'col1')</code></pre>

<h4 id="emit_processor">Emit Processor</h4>

<ul>
<li>Kafka Emit Processor</li>
</ul>

<blockquote>
<p>TupleをKafkaに出力します。</p>
</blockquote>

<pre><code>kafka_emit(topic_name)</code></pre>

<blockquote>
<ul>
<li>topic_name には、出力するTopic名を指定します。topic_name はプロセッサ変数に対応しています。</li>
</ul>

<p>Example:</p>
</blockquote>

<pre><code>kafka_emit('topic1')</code></pre>

<ul>
<li>Mongo Persist Processor</li>
</ul>

<blockquote>
<p>TupleをMongoDBに出力します。</p>
</blockquote>

<pre><code>mongo_persist(db_name, collection_name [, key_names])</code></pre>

<blockquote>
<ul>
<li>db_name には、出力するDB名を指定します。db_name はプロセッサ変数に対応しています。</li>

<li>collection_name には、出力するCollection名を指定します。collection_name はプロセッサ変数に対応しています。</li>

<li>key_names には、出力するキーのフィールド名を指定します。複合キーの場合は配列で指定してください。 key_names を指定した場合、出力はキーに対してupdateされます。 key_names を指定しなかった場合は、出力はinsertになります。</li>
</ul>

<p>Example:</p>
</blockquote>

<pre><code>mongo_persist('db1', 'col1')  &lt;- insert
mongo_persist('db1', 'col1', 'field2') &lt;- field2 をキーとしてupdate
mongo_persist('db1', 'col1', ['field2', 'field3']) &lt;- field2 + field3 を複合キーとしてupdate</code></pre>

<h4 id="プロセッサ変数">プロセッサ変数</h4>

<p>Emit Processor の出力先の名称には、以下のプロセッサ変数を含めることができます。</p>

<p>${TOPOLOGY_ID} は、起動中のTopology IDに置き換えられます。 ${ACCOUNT_ID} は、Topologyを起動したユーザのAccount IDに置き換えられます。</p>

<blockquote>
<p>Example:</p>
</blockquote>

<pre><code>kafka_emit('topic_${TOPOLOGY_ID}')</code></pre>

					  </body>
				  </html>
